\chapter{逆向工程}
\section{乙组基准-simple\_vm}
一个简单的vm，用switch语句做的，进去F5就能看到，推导出有哪些指令和格式就好了。题目也给了一段指令，要求输入三个数字，然后运行这段指令，对这三个数进行运算后，栈中某个位置结果是0，输入的三个数字就是flag。

最主要的点在于看栈、寄存器和其他参数的内存位置，然后把题目给的指令解析出来，列出算式解方程。

\section{乙组基准-anti\_patience}
这个题目直接用ida逆向会有一些地方解析失败，需要手动patch，把对应位置patch为nop，这里用LazyIDA插件，填充为nop后就可以生成伪代码了。

题目还用ptrace判断当前进程有没有被gdb调试，那个位置也需要patch，否则调试的时候随机数种子和正常运行的时候不一样。最后发现整个程序需要输入一段字符串，这段字符串进行很长一段逐字符运算后，得到一个res，然后题目中也有一个准备好的字符串，这个字符串逐字节和随机数进行运算，得到一个target\_res。最后对这两个结果进行比较，相等则输出flag，这个flag也是由随机数生成的。

解题步骤:
\begin{itemize}
    \item patch解析失败的地方。
    \item patch反调试的地方，使调试时随机种子不变。
    \item gdb调试，在检查结果的时候下断点，获取target\_res。
    \item 把输入字符串的运算过程copy出来，改成一个暴力求解过程。就可以获得flag了。
\end{itemize}